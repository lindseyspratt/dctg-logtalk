:- object(dctg,	imports([print_tree, translate])).	:- info([		version is 1:0:0,		author is 'Lindsey Spratt',		date is 2022-2-12,		comment is 'Definite Clause Translation Grammar, based on the work of Harvey Abramson.'	]).	:- public(dctg_process/2).	:- mode(dctg_process(+evaluable, -clause), one).	:- info(dctg_process/2, [		comment is 'Process a Definite Clause Translation Grammar expression to create a Prolog clause that implements the expression.',		argnames is ['DCTGExpression', 'Clause']	]).	:- public(dctg_consult/1).	:- mode(dctg_consult(+file_path), one).	:- info(dctg_consult/1, [		comment is 'Process the Definite Clause Grammar expressions in the given File.',		argnames is ['File']	]).	:- public(dctg_sentence/1).	:- mode(dctg_sentence(+list), one).	:- info(dctg_sentence/1, [		comment is 'Process the List using the DCTG predicate sentenceDCTG/3 (this presumes having processed a DCTG expression with the name "sentence").',		argnames is ['List']	]).	:- public((^^)/2).	:- mode(^^(+term, +term), one_or_more).	:- info((^^)/2, [		comment is 'The ^^ predicate evaluates the DCTG semantic Goals to with respect to the DCTG Tree semantics.',		argnames is ['Tree', 'Goals']	]).	/*	This Logtalk implementation of the Definite Clause Translation Grammar is	based on an implementation created by Lindsey Spratt in December, 1986,	which in turn was based on "Definite Clause Translation Grammars" by	Harvey Abramson in Proceedings of the Logic Programming Symposium,	IEEE, Atlantic City, New Jersey, February 1984.	*/	:- include(operators).	dctg_process((LP::=[]<:>Sem),H) :-		!,		::t_lp(LP, [], S, S, Sem, H).	dctg_process((LP::=[]), H) :-		!,		::t_lp(LP, [], S, S, true, H).	dctg_process((LP::=RP<:>Sem), (H:-B)) :-		!,		::t_rp(RP, [], StL, S, SR, B1),		utilities::reverse(StL, RStL),		::t_lp(LP, RStL, S, SR, Sem, H),		utilities::tidy(B1, B).	dctg_process((LP::=RP), (H:-B)) :-		!,		dctg_process((LP::=RP<:>true), (H:-B)).	dctg_process(Clause, Clause).%	dctg_process(ClauseIN, ClauseOUT) :-%		expand_dcg(ClauseIN, ClauseOUT).	dctg_consult(File) :-		%setup_call_cleanup(			see(File),			dctg_consume,			seen.		%	).	dctg_consume :-		read(X),		dctg_process(X,Y),		assertz(Y),		!,		dctg_consume.	dctg_consume./*	dctg_sentence(Source) :-		sentenceDCTG(T, Source, []),		::dctg_print_tree(T),		T ^^ logic(Proposition),		nl,		write(Proposition).*/	c([X|S], X, S).	node(Name, _, Sem) ^^ Args :-		trace_node_message('call','fail',Name, Sem, Args),		(var(Sem)			-> utilities::writeseqnl(['Unable to apply', Args, 'to a node because the semantics is an unbound variable.']),			   throw(error(instantiation_error, (^^)/2))		; dctg_eval(Sem, Args) % Sem ^^ Args		),		trace_node_message('exit','redo',Name, Sem, Args).	:- meta_predicate(dctg_eval(*,*)).		dctg_eval(((Args ::- Traverse), _Rules), Args) :-		!,		trace_message('call','fail',Args,Traverse),		call(Traverse),		trace_message('exit','redo',Args,Traverse).	dctg_eval((Args, _Rules), Args) :- !.	dctg_eval((_, Rules), Args) :-		dctg_eval(Rules, Args).	dctg_eval((Args ::- Traverse), Args) :-		trace_message('call','fail', Args, Traverse),		call(Traverse),		trace_message('exit','redo', Args, Traverse).	dctg_eval(Args, Args).	/*	((Args ::- Traverse), Rules) ^^ Args :-	!,	trace_message('call','fail',Args,Traverse),	call(Traverse),	trace_message('exit','redo',Args,Traverse).	(Args, Rules) ^^ Args :- !.	(_, Rules) ^^ Args :-	Rules ^^ Args.	(Args ::- Traverse) ^^ Args :-	trace_message('call','fail', Args, Traverse),	call(Traverse),	trace_message('exit','redo', Args, Traverse).	Args ^^ Args.	*/	trace_node_message(Success, Failure, Name, Sem, Args) :-		traced_attachment(Args)		  -> (	nl,				write(Success),				utilities::tab(1),		   	 	trace_node_message1(Name, Sem, Args)		     ;			 	nl,				write(Failure),				utilities::tab(1),		    	trace_node_message1(Name, Sem, Args),		    	!,		    	fail			 )		; true.	trace_node_message1(Name, Sem, Args) :-		write('attachment: '),		print(Args),		nl,		write('on node: '),		::print_node(Name, Sem).	trace_message(_Success,_Failure,Args,_Body) :-		\+ traced_attachment(Args),		!.	trace_message(Success,_Failure,_Args,Body) :-		write(Success),		utilities::tab(1),		::print_semantics(Body),		nl.	trace_message(_Success, Failure, _Args,Body) :-		write(Failure),		utilities::tab(1),		::print_semantics(Body),		nl,		!,		fail.	:- dynamic('dctg$trace'/1).	:- dynamic('dctg$notrace'/1).	traced_attachment(Args) :-		\+ \+ 'dctg$trace'(Args),		\+ 'dctg$notrace'(Args).	dctg_trace(F) :-		assertz('dctg$trace'(F)),		retractall('dctg$notrace'(F)).	dctg_untrace(F) :-		retractall('dctg$trace'(F)).	dctg_notrace :-		retractall('dctg$trace'(_)).	dctg_notrace(F) :-		assertz('dctg$notrace'(F)),		retractall('dctg$trace'(F)).		:- end_object.